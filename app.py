from flask import Flask, render_template, request, jsonify, redirect
import requests
import os
import json
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

app = Flask(__name__)

# Get Databricks token from environment variable
DATABRICKS_TOKEN = os.getenv("DATABRICKS_TOKEN")
# Databricks serving endpoint URL
DATABRICKS_ENDPOINT = os.getenv("DATABRICKS_ENDPOINT")

# Flag to use mock responses when Databricks token is not available or invalid
USE_MOCK_RESPONSES = True if not DATABRICKS_TOKEN else False

# Initialize chat history with system message
chat_history = [
    {
        "role": "system", 
        "content": (
            """
            You are an advanced AI designed to interpret insights from a machine learning clustering model trained on datasets related to changes, incidents, and services within an organization. 
Your role is to assist users in proposing actionable plans based on these insights, enabling a shift from reactive to preventive strategies for managing incidents and changes.

Context:
Two clustering models analyze two primary datasets:

Changes Dataset: Contains information about infrastructure changes, including their type (categorized by Categorization Tier 1), associated services, assigned providers, and time-to-complete (calculated as Scheduled_end_date - Scheduled_start_date). 
The data has been preprocessed to group similar categories into 25 distinct types for better cluster separation.

Incidents Dataset: Contains information about incidents, including their type (categorized into two tiers, with Tier 1 containing five main types: INFRAESTRUCTURA, DESPLEGAMENT MULTIAMBIT, DESPLEGAMENT, SEGURETAT, INFRAESTRUCTURA MULTIAMBIT), and time-to-resolve (calculated as Closed_Date - Submit_Date).

The clustering model uses two key features for analysis:

Type: Represents the category of the change or incident.
Time-to-Complete/Resolve: Represents the duration required to complete a change or resolve an incident.

Objective:
Your task is to:

Interpret Clustering Results: Analyze the clusters generated by the model to identify patterns, such as common types of changes or incidents that frequently lead to critical issues or delays.
Propose Action Plans: Based on the insights from the clustering model, propose actionable strategies to mitigate risks, prevent incidents, and optimize resource allocation. For each proposed action plan, include:
A detailed description of the recommended steps.
The percentage of confidence in the effectiveness of the action plan, derived from the clustering model's insights.
Relate Changes to Potential Incidents: Leverage the clustering results to predict potential incidents that could arise from specific types of changes. Suggest preventive measures to address these risks proactively.

Example Workflow:
If the clustering model identifies a cluster of changes with high time-to-complete values and frequent critical incidents, recommend actions such as:
Conducting a root cause analysis for these changes.
Providing additional training to the assigned provider groups.
Allocating more resources to reduce delays.
Confidence level: 85% (based on historical data showing a strong correlation between high time-to-complete and critical incidents).
If the clustering model identifies a cluster of incidents related to a specific service type (e.g., INFRAESTRUCTURA), recommend actions such as:
Prioritizing maintenance for services in this category.
Implementing automated monitoring tools to detect anomalies early.
Confidence level: 90% (based on historical data showing recurring issues with this service type).

Constraints:
The canvis_incidencies_relacionades table currently has only 400 relationships, limiting the ability to directly link changes to incidents. You may need to infer relationships based on clustering patterns.
Ensure that your recommendations are practical, actionable, and aligned with the organization's goals of saving time, money, and resources.

Output Format:
For each insight derived from the clustering model, provide:

A brief summary of the identified pattern or risk.
A detailed action plan to address the issue.
The percentage of confidence in the proposed action plan, along with a justification for the confidence level.
Your responses should be data-driven, and tailored to help the user implement preventive measures effectively.

Gather information about the change from the user. Ask them to provide:

1. Change Type (Categorization Tier 1):
   - INFRAESTRUCTURA
   - DESPLEGAMENT MULTIAMBIT
   - DESPLEGAMENT
   - SEGURETAT
   - INFRAESTRUCTURA MULTIAMBIT

2. Service Information:
   - Affected service ID
   - Service CI

3. Additional Context:
   - Detailed description
   - Priority level
   - Any specific concerns

Once you receive this information, analyze it against the clustering model results to:
1. Identify patterns and potential risks
2. Propose preventive measures
3. Provide actionable recommendations
4. Include confidence levels based on historical data

Start by asking the user to provide these details about their change.

Remember:
- Keep your responses focused and practical
- Include specific confidence levels for each recommendation
- Base insights on the clustering model's historical patterns
- Consider both direct and inferred relationships between changes and incidents

Please begin by asking the user for the change details in a clear, structured format.
"""
        )
    }
]

# Mock responses for testing when Databricks token is not available
mock_responses = {
    "default": "I'm currently in demo mode since there's no valid Databricks token configured. In a production environment, I would analyze your clustering data and provide actionable insights. Please provide a valid Databricks token in the .env file to enable full functionality.",
    
    "infrastructure": "Based on the clustering analysis, I've identified a pattern where INFRASTRUCTURE changes with duration over 72 hours have a 78% correlation with critical incidents.\n\nAction Plan:\n1. Implement a mandatory peer review for all infrastructure changes exceeding 48 hours\n2. Create automated testing scripts for common infrastructure modifications\n3. Schedule complex changes during low-traffic periods\n\nConfidence: 85% - This recommendation is based on historical patterns showing that proper review and scheduling reduces incident rates by approximately 40%.",
    
    "deployment": "The clustering model has identified that DEPLOYMENT changes across multiple environments have a 65% higher risk of causing incidents.\n\nAction Plan:\n1. Implement a staged deployment approach with validation checkpoints\n2. Create environment-specific rollback procedures\n3. Establish a 24-hour monitoring protocol after multi-environment deployments\n\nConfidence: 92% - Organizations implementing these measures have seen a 73% reduction in deployment-related incidents according to our model.",
    
    "security": "Security-related changes show a distinct cluster with high incident correlation, particularly when implemented with less than 48 hours of planning.\n\nAction Plan:\n1. Establish a minimum 72-hour planning window for all security changes\n2. Implement a dedicated security testing environment\n3. Create a security change impact assessment template\n\nConfidence: 88% - Based on cluster analysis showing that security changes with proper planning have 4.3x fewer associated incidents."
}

@app.route('/')
def root():
    return redirect('/mpcdc')

@app.route('/mpcdc')
def index():
    return render_template('index.html', use_mock=USE_MOCK_RESPONSES)

@app.route('/mpcdc/chat', methods=['POST'])
def chat():
    user_input = request.json.get('message', '')
    
    if not user_input:
        return jsonify({"error": "Message cannot be empty"}), 400
    
    # If using mock responses, return a predefined response based on keywords
    if USE_MOCK_RESPONSES:
        response = get_mock_response(user_input)
        return jsonify({"response": response})
    
    # Make a copy of the chat history for this request
    current_chat_history = list(chat_history)
    
    # Append user message to chat history
    current_chat_history.append({"role": "user", "content": user_input})
    
    # Request payload
    data = {
        "messages": current_chat_history,
        "max_tokens": 256
    }
    
    # Request headers
    headers = {
        "Authorization": f"Bearer {DATABRICKS_TOKEN}",
        "Content-Type": "application/json"
    }
    
    try:
        # Make the request to Databricks
        response = requests.post(DATABRICKS_ENDPOINT, headers=headers, json=data)
        
        # Handle response
        if response.status_code == 200:
            ai_response = response.json().get("choices")[0].get("message").get("content")
            return jsonify({"response": ai_response})
        else:
            # If there's an error with the Databricks API, switch to mock responses
            app.logger.error(f"Databricks API error: {response.status_code} - {response.text}")
            return jsonify({
                "response": f"I encountered an issue connecting to the Databricks API. Using demo mode instead.\n\n{get_mock_response(user_input)}"
            })
    except Exception as e:
        app.logger.error(f"Exception when calling Databricks API: {str(e)}")
        return jsonify({
            "response": f"I encountered an error: {str(e)}. Using demo mode instead.\n\n{get_mock_response(user_input)}"
        })

def get_mock_response(user_input):
    """Return a mock response based on keywords in the user input"""
    user_input_lower = user_input.lower()
    
    if "infrastructure" in user_input_lower or "infraestructura" in user_input_lower:
        return mock_responses["infrastructure"]
    elif "deployment" in user_input_lower or "desplegament" in user_input_lower:
        return mock_responses["deployment"]
    elif "security" in user_input_lower or "seguretat" in user_input_lower:
        return mock_responses["security"]
    else:
        return mock_responses["default"]

@app.route('/mpcdc/status')
def status():
    """Endpoint to check if the Databricks API is accessible"""
    if USE_MOCK_RESPONSES:
        return jsonify({
            "status": "demo",
            "message": "Application is running in demo mode. Set a valid DATABRICKS_TOKEN in the .env file to enable full functionality."
        })
    
    try:
        # Simple test request to Databricks
        headers = {
            "Authorization": f"Bearer {DATABRICKS_TOKEN}",
            "Content-Type": "application/json"
        }
        
        # Minimal payload just to test authentication
        data = {
            "messages": [{"role": "user", "content": "test"}],
            "max_tokens": 10
        }
        
        response = requests.post(DATABRICKS_ENDPOINT, headers=headers, json=data)
        
        if response.status_code == 200:
            return jsonify({
                "status": "connected",
                "message": "Successfully connected to Databricks API"
            })
        else:
            return jsonify({
                "status": "error",
                "message": f"Error connecting to Databricks API: {response.status_code} - {response.text}"
            })
    except Exception as e:
        return jsonify({
            "status": "error",
            "message": f"Exception when connecting to Databricks API: {str(e)}"
        })

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0')
